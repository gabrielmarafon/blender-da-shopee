<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="16x16"
    href="https://www.blender.org/wp-content/themes/bthree/assets/icons/favicon-16x16.png">
  <title>Blender da Shopee</title>
  <script src="https://cdn.jsdelivr.net/npm/phosphor-icons@1.4.2/src/index.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/phosphor-icons@1.4.2/src/css/icons.min.css" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <script src="https://unpkg.com/phosphor-icons"></script>
</head>

<body>
  <div class="container">
    <header class="toolbar">
      <nav>
        <ul>
          <li>File</li>
          <li>Edit</li>
          <li>Render</li>
          <li>Help</li>
        </ul>
        <img class="logo" src="./logo.png" alt="Blender" />
      </nav>
      <div class="tools">
        <span id="helper-text"></span>
      </div>
    </header>
    <main class="content">
      <div id="work-container">
        <div id="vertical-tools"></div>
        <div id="canvas-container">
          <canvas id="blender-canvas" style="background-color: #AAA;"></canvas>
        </div>
        <div class="display-info">
          <div id="coordinates">Coordenadas: (0, 0)</div>
        </div>
      </div>
      <div class="sidebar">
        <div class="layers-section">
          <h3>Camadas</h3>
          <ul class="layers-list" id="layers-list"></ul>
        </div>
      </div>
    </main>
  </div>
  <script>
    const RECT_TYPES = {
      dot: "dot",
      line: "line",
      polygon: "polygon",
    }
    const ICONS = {
      cursor: "ph ph-cursor",
      dot: "ph-fill ph-dots-three-outline",
      trash: "ph ph-trash",
      line: "ph ph-line-segment",
      polygon: "ph ph-polygon",
    }
    const VERTICAL_TOOLS = [
      { id: "cursor", icon: ICONS.cursor, label: "Cursor" },
      { id: "addDot", icon: ICONS.dot, label: "Adicionar ponto" },
      { id: "addLine", icon: ICONS.line, label: "Adicionar linha" },
      { id: "addPolygon", icon: ICONS.polygon, label: "Adicionar polígono" },
    ]

    const HELPER_TEXT = {
      addDot: "Adicionar ponto: clique na tela para criar o ponto",
      addLine: "Adicionar linha: Clique e arraste para criar uma linha",
      addPolygon: "Adicionar polígono: Adicione pontos clicando na tela e pressione Enter",
    }

    class Rect {
      constructor(type, name, position) {
        this.id = Math.random();
        this.type = type;
        this.name = name;
        this.position = position;
      }
      setName(name) {
        this.name = name;
      }
      draw() {
        if (this.type === RECT_TYPES.dot) {
          ctx.beginPath();
          ctx.arc(this.position[0], this.position[1], 3, 0, Math.PI * 2);
          ctx.fillStyle = 'black';
          ctx.fill();
        } else if (this.type === RECT_TYPES.line) {
          ctx.beginPath();
          ctx.moveTo(this.position[0][0], this.position[0][1]);
          ctx.lineTo(this.position[1][0], this.position[1][1]);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        } else if (this.type === RECT_TYPES.polygon) {
          ctx.beginPath();
          ctx.moveTo(this.position[0][0], this.position[0][1]);
          for (let i = 1; i < this.position.length; i++) {
            ctx.lineTo(this.position[i][0], this.position[i][1]);
          }
          ctx.closePath();
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        else {
          console.error("\"" + this.name + "\" has an unknown Rect type.")
        }
      }
    }
    const appState = {
      currentTool: VERTICAL_TOOLS[0].id,
      isDrawing: false,
      cursorState: null,
      layers: [
        // new Rect(RECT_TYPES.dot, "Ponto 1", [100, 100]),
        // new Rect(RECT_TYPES.dot, "Ponto 2", [100, -100]),
        // new Rect(RECT_TYPES.dot, "Ponto 3", [0, 0]),
        // new Rect(RECT_TYPES.dot, "Ponto 4", [-100, 100]),
        // new Rect(RECT_TYPES.dot, "Ponto 5", [-100, -100]),
        // new Rect(RECT_TYPES.line, "Linha 1", [[100, -100], [-100, -100]]),
        // new Rect(RECT_TYPES.line, "Linha 2", [[100, -100], [-100, 100]]),
        new Rect(RECT_TYPES.polygon, "Polígono 2", [[0, 0], [0, -50], [-50, -50], [-50, 0], [-25, 25]]),
        // new Rect(RECT_TYPES.polygon, "Polígono 2", [[100, -150], [-50, 100], [-200, 100], [-200, -200]]),
      ]
    }

    function removeLayer(id) {
      appState.layers = appState.layers.filter(l => l.id !== id);
      renderApp();
    }

    function renderVerticalTools() {
      const verticalTools = document.getElementById('vertical-tools');
      verticalTools.innerHTML = "";
      for (const tool of VERTICAL_TOOLS) {
        const button = document.createElement('button');
        button.className = appState.currentTool === tool.id ? "active" : "";
        button.onclick = () => setCurrentTool(tool.id)
        const icon = document.createElement('i');
        icon.className = tool.icon;
        button.appendChild(icon);
        verticalTools.appendChild(button)
      }
    }

    function renderLayersList() {
      const layersList = document.getElementById('layers-list');
      layersList.innerHTML = "";
      for (const layer of appState.layers) {
        const li = document.createElement('li');

        const icon = document.createElement('i');
        icon.className = ICONS[layer.type];
        li.appendChild(icon);

        const text = document.createElement('input');
        text.id = "layer-input-" + layer.id;
        text.value = layer.name;
        text.onblur = event => {
          console.log(event.currentTarget.value.trim());
          if (!event.currentTarget.value.trim()) {
            text.value = layer.name;
          } else {
            appState.layers = appState.layers.map(l => {
              if (l.id === layer.id) {
                layer.setName(event.currentTarget.value)
              }
              return l
            });
          }

        }
        li.appendChild(text);

        const deleteButton = document.createElement('button');
        deleteButton.className = `${ICONS.trash} delete-button`;
        deleteButton.onclick = () => removeLayer(layer.id)
        li.appendChild(deleteButton);


        layersList.appendChild(li);
      }
    }

    function renderApp() {
      console.log(appState.layers);

      clearCanvas(ctx)
      renderLayersList();
      renderVerticalTools();
      for (const layer of appState.layers) {
        layer.draw();
      }
    }

    function setCurrentTool(tool) {
      appState.currentTool = tool;
      appState.cursorState = {};
      const canvasContainer = document.getElementById('canvas-container');
      const helperText = document.getElementById('helper-text');
      if (tool === "cursor") {
        helperText.innerText = "";
        appState.isDrawing = false;
        canvasContainer.style.cursor = 'inherit';
      } else {
        helperText.innerText = HELPER_TEXT[tool];
        appState.isDrawing = true;
        canvasContainer.style.cursor = 'crosshair';
      }
      renderVerticalTools();
    }
    function clearCanvas(context) {
      const W = context.canvas.width, H = context.canvas.height;
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.clearRect(0, 0, W, H);
      context.setTransform(1, 0, 0, -1, W / 2, H / 2);
    }
    const coordinatesDisplay = document.getElementById('coordinates');
    const canvas = document.getElementById("blender-canvas");
    var ctx = canvas.getContext("2d");
    canvas.height = window.innerHeight - 64 - 23;
    canvas.width = window.innerWidth - 280;
    const W = ctx.canvas.width, H = ctx.canvas.height;
    clearCanvas(ctx)

    // ctx.setTransform(2, 0, 0, 2, W / 2, H / 2); // zooms in by 2 with origin at center
    // ctx.setTransform(0.5, 0, 0, 0.5, W / 2, H / 2); // zooms out by 2 with origin at center

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left - W / 2;
      const y = - (evt.clientY - rect.top - H / 2)
      return { x: x, y: y };
    }
    canvas.addEventListener('mousemove', (event) => {
      const { x, y } = getMousePos(event);
      coordinatesDisplay.textContent = `Coordenadas: (${x}, ${y})`;
    });

    canvas.addEventListener('click', (event) => {
      if (appState.currentTool === "addDot") {
        const { x, y } = getMousePos(event);
        const newName = "Ponto " + appState.layers.filter(l => l.type === "dot").length
        const rect = new Rect(RECT_TYPES.dot, newName, [x, y])
        appState.layers.push(rect);
        renderApp();
      }

      if (appState.currentTool === "addPolygon") {
        const { x, y } = getMousePos(event);
        const polygonPosition = [x, y]
        if (!appState?.cursorState?.polygonPositions)
          appState.cursorState = {
            polygonPositions: []
          }

        appState.cursorState.polygonPositions.push(polygonPosition);
      }
    });

    function keyDownEvents(event) {
      if (appState.currentTool === "addPolygon") {
        if (event.key === "Enter") {
          if (appState?.cursorState?.polygonPositions?.length < 3) {
            alert("Adicione pelo menos 3 pontos para criar um polígono");
            return;
          }
          const newName = "Polígono " + appState.layers.filter(l => l.type === "polygon").length
          const rect = new Rect(RECT_TYPES.polygon, newName, appState.cursorState.polygonPositions)
          appState.layers.push(rect);
          appState.cursorState.polygonPositions = [];
          renderApp();
        }
      }
    }

    function startLine(event) {
      if (appState.currentTool === "addLine") {
        const { x, y } = getMousePos(event);

        appState.cursorState = { mousedownPosition: [x, y] }
      }
    }

    function endLine(event) {
      if (appState.currentTool === "addLine") {
        const { x, y } = getMousePos(event);

        const startPosition = appState.cursorState?.mousedownPosition;
        if (startPosition) {
          const endPosition = [x, y]
          const newName = "Linha " + appState.layers.filter(l => l.type === "line").length
          const rect = new Rect(RECT_TYPES.line, newName, [startPosition, endPosition])
          appState.layers.push(rect);
          appState.cursorState = null;
          renderApp();
        }
      }
    }

    canvas.addEventListener('mousedown', startLine);
    canvas.addEventListener('mouseup', endLine);
    window.addEventListener('keydown', keyDownEvents);

    addEventListener("resize", () => {
      canvas.height = window.innerHeight - 64 - 23;
      canvas.width = window.innerWidth - 280;

      clearCanvas(ctx);
      renderApp();
    })
    renderApp();
  </script>
</body>

</html>